// services/AppManager.ts
import jwtDecode from 'jwt-decode';

function base64urlencode(str: ArrayBuffer): string {
  return btoa(String.fromCharCode(...new Uint8Array(str)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

async function generateCodeChallenge(verifier: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const digest = await crypto.subtle.digest('SHA-256', data);
  return base64urlencode(digest);
}

function generateCodeVerifier(length = 128): string {
  const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
  let result = '';
  const values = crypto.getRandomValues(new Uint8Array(length));
  for (let i = 0; i < length; i++) {
    result += charset[values[i] % charset.length];
  }
  return result;
}

const AppManager = {
  async authorize() {
    const verifier = generateCodeVerifier();
    const challenge = await generateCodeChallenge(verifier);

    sessionStorage.setItem('pkce_verifier', verifier);

    const params = new URLSearchParams({
      response_type: 'code',
      client_id: process.env.NEXT_PUBLIC_CLIENT_ID!,
      redirect_uri: process.env.NEXT_PUBLIC_REDIRECT_URI!,
      scope: 'openid profile email',
      code_challenge: challenge,
      code_challenge_method: 'S256',
      state: 'abc123', // Tu peux générer dynamiquement si besoin
    });

    window.location.href = `${process.env.NEXT_PUBLIC_AUTH_URL!}?${params.toString()}`;
  },

  async handleCallback(code: string, state: string | null) {
    const verifier = sessionStorage.getItem('pkce_verifier');
    if (!verifier) throw new Error('PKCE verifier not found');

    const params = new URLSearchParams({
      grant_type: 'authorization_code',
      code,
      redirect_uri: process.env.NEXT_PUBLIC_REDIRECT_URI!,
      client_id: process.env.NEXT_PUBLIC_CLIENT_ID!,
      code_verifier: verifier,
    });

    const response = await fetch(process.env.NEXT_PUBLIC_TOKEN_URL!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: params.toString(),
    });

    if (!response.ok) {
      throw new Error('Échec de récupération du token');
    }

    const data = await response.json();
    const decoded = jwtDecode(data.id_token);

    localStorage.setItem('access_token', data.access_token);
    localStorage.setItem('id_token', data.id_token);
    localStorage.setItem('user_info', JSON.stringify(decoded));
  }
};

export default AppManager;

// app/callback/page.tsx
'use client';

import { useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import AppManager from '@/services/AppManager';

const CallbackPage = () => {
  const router = useRouter();
  const searchParams = useSearchParams();

  useEffect(() => {
    const code = searchParams.get('code');
    const state = searchParams.get('state');

    if (code) {
      AppManager.handleCallback(code, state)
        .then(() => {
          router.push('/core/homePage'); // Rediriger selon rôle si besoin
        })
        .catch((err) => {
          console.error('Erreur callback OAuth:', err);
          router.push('/error');
        });
    }
  }, [searchParams, router]);

  return <div className="p-10 text-center text-lg">Connexion en cours...</div>;
};

export default CallbackPage;
NEXT_PUBLIC_CLIENT_ID=ton_client_id
NEXT_PUBLIC_REDIRECT_URI=http://localhost:3000/callback
NEXT_PUBLIC_AUTH_URL=https://auth.sgconnect.com/oauth/authorize
NEXT_PUBLIC_TOKEN_URL=https://auth.sgconnect.com/oauth/token
