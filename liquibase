import datetime
import requests
import time
import json
import re
from generate_description import generate_description

LOKI_URL = "http://localhost:3100/loki/api/v1/query_range"

# ‚úÖ D√©tection d'incident
def is_incident(message):
    return any(keyword in message.lower() for keyword in [
        "exception", "error", "failed", "refused", "timed out", "unknownhost"
    ])

# üåç Extraction de l'environnement
def parse_environment(service_name):
    if "int" in service_name.lower():
        return "DEV"
    elif "uat" in service_name.lower():
        return "HF"
    elif "oat" in service_name.lower():
        return "HT"
    return "UNKNOWN"

# üß™ Regex fallback pour logs non JSON
def parse_log_fallback_regex(log_line):
    level_match = re.search(r"\b(DEBUG|INFO|WARN|ERROR|TRACE|FATAL)\b", log_line)
    trace_match = re.search(r'"?traceid"?[:=]\s*"?([a-fA-F0-9\-]{8,})"?', log_line, re.IGNORECASE)
    service_match = re.search(r"\[([^\]]+)\]", log_line)
    entity_match = re.search(r'Entity\s+([A-Z]{2})', log_line)

    service = service_match.group(1) if service_match else "unknown_service"
    level = level_match.group(1) if level_match else "N/A"
    entity = entity_match.group(1) if entity_match else "N/A"
    environment = parse_environment(service)

    return {
        "timestamp": "N/A",
        "level": level,
        "service_name": service,
        "environment": environment,
        "trace_id": trace_match.group(1) if trace_match else "N/A",
        "entity": entity,
        "message": log_line,
        "incident": "üö®" if is_incident(log_line) else "",
        "description": generate_description({
            "message": log_line,
            "service_name": service,
            "level": level
        })
    }

# üîç Parsing de log JSON (OpenTelemetry)
def parse_otel_log(log_line, default_service_name="unknown_service", raw_ts=None):
    try:
        obj = json.loads(log_line)
        timestamp = (
            datetime.datetime.utcfromtimestamp(int(raw_ts[:10]))
            .strftime('%Y-%m-%d %H:%M:%S') if raw_ts else "N/A"
        )
        level = obj.get("severity") or obj.get("severityText") or obj.get("level") or "N/A"
        resource = obj.get("resource", {}) or {}

        service = (
            resource.get("service.name") or
            obj.get("service.name") or
            obj.get("service_name") or
            default_service_name
        )
        message = obj.get("body") or obj.get("message") or str(obj)
        environment = parse_environment(service)

        trace_id = (
            obj.get("trace_id") or
            obj.get("traceId") or
            obj.get("attributes", {}).get("trace_id") or
            resource.get("trace_id")
        )
        if not trace_id:
            match = re.search(r'"?traceid"?[:=]\s*"?([a-fA-F0-9\-]{8,})"?', message, re.IGNORECASE)
            trace_id = match.group(1) if match else "N/A"

        entity_match = re.search(r'Entity\s+([A-Z]{2})', message)
        entity = entity_match.group(1) if entity_match else "N/A"

        description = generate_description({
            "message": message,
            "service_name": service,
            "level": level
        })

        return {
            "timestamp": timestamp,
            "level": level,
            "service_name": service,
            "environment": environment,
            "trace_id": trace_id,
            "entity": entity,
            "message": message,
            "incident": "üö®" if is_incident(message) else "",
            "description": description
        }

    except (json.JSONDecodeError, TypeError):
        return parse_log_fallback_regex(log_line)

# üì° R√©cup√©ration des logs depuis Loki
def get_logs():
    now = int(time.time() * 1_000_000_000)
    start = now - 60 * 1_000_000_000

    query = '{service_name=~".+"}'

    params = {
        "query": query,
        "start": start,
        "end": now,
        "limit": 100,
        "direction": "forward"
    }

    try:
        response = requests.get(LOKI_URL, params=params)
        response.raise_for_status()
        data = response.json()

        logs = []
        for stream in data.get("data", {}).get("result", []):
            service_label = stream.get("stream", {}).get("service_name", "unknown_service")

            for entry in stream.get("values", []):
                raw_ts, log_line = entry
                print("\nüîç Log brut r√©cup√©r√© :")
                print(log_line)

                with open("raw_logs.txt", "a", encoding="utf-8") as f:
                    f.write(log_line + "\n")

                parsed = parse_otel_log(log_line, service_label, raw_ts)
                logs.append(parsed)

        return logs

    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erreur lors de l'appel √† Loki : {e}")
        return []

# üßµ Analyse des erreurs par trace_id
def detect_failing_endpoints(logs):
    trace_map = {}
    for log in logs:
        trace_id = log.get("trace_id")
        if not trace_id or trace_id == "N/A":
            continue
        trace_map.setdefault(trace_id, []).append(log)

    failing_endpoints = []
    for trace_id, entries in trace_map.items():
        has_error = any(log["level"].upper() == "ERROR" for log in entries)
        if has_error:
            endpoint = None
            for log in entries:
                match = re.search(r"(GET|POST|PUT|DELETE)\s+(/[^\s]+)", log["message"])
                if match:
                    endpoint = match.group(2)
                    break
            failing_endpoints.append({
                "trace_id": trace_id,
                "endpoint": endpoint or "unknown",
                "service": entries[0]["service_name"],
                "error_message": [l["message"] for l in entries if l["level"].upper() == "ERROR"],
                "timestamp": entries[0]["timestamp"]
            })

    return failing_endpoints

# üñ•Ô∏è Affichage console
def display_logs(logs):
    print("\nüìã Logs r√©cup√©r√©s :\n")
    for log in logs:
        print(f"‚è±Ô∏è  Time         : {log['timestamp']}")
        print(f"ü™µ  Level        : {log['level']}")
        print(f"üß©  Service      : {log['service_name']} {log['incident']}")
        print(f"üåç  Environnement: {log['environment']}")
        print(f"üè∑Ô∏è  Entity       : {log.get('entity', 'N/A')}")
        print(f"üßµ  Trace ID     : {log['trace_id']}")
        print(f"üìù  Message      : {log['message']}")
        print(f"üìå  Description  : {log['description']}\n")

# üíæ Sauvegarde incidents
def save_incidents_to_file(logs, filename="incidents.txt"):
    incidents = [log for log in logs if log["incident"] == "üö®"]
    if not incidents:
        return

    with open(filename, "a", encoding="utf-8") as f:
        for incident in incidents:
            f.write(json.dumps(incident, ensure_ascii=False) + "\n")

# üîÅ Boucle principale
def run_loop():
    print("üì° R√©cup√©ration des logs OpenTelemetry depuis Loki...\n")
    while True:
        logs = get_logs()
        if logs:
            print(f"\n‚úÖ {len(logs)} logs r√©cup√©r√©s")
            display_logs(logs)

            errors = detect_failing_endpoints(logs)
            if errors:
                print("\n‚ùó Endpoints en erreur d√©tect√©s :")
                print(json.dumps(errors, indent=4, ensure_ascii=False))

            save_incidents_to_file(logs)
        else:
            print("‚ö†Ô∏è Aucun log trouv√©.")
        time.sleep(10)

# ‚ñ∂Ô∏è Lancement
if __name__ == "__main__":
    run_loop()
