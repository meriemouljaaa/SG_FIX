import axios from "axios";
import { IncidentDetail } from "../models/IncidentDetail";
import { Incident } from "../models/Incident";

const API_URL = "http://localhost:8080/incident";

export const IncidentService = {
createIncident: async (formData: FormData): Promise<any> => {
  try {
    const response = await axios.post(API_URL, formData, {
      headers: { "X-EntityId": "BF" },
    });
    return response.data;
  } catch (error) {
    throw error;
  }
},


  getAllIncidents: async (): Promise<IncidentDetail[]> => {
    try {
      const response = await axios.get(API_URL, {
        headers: {
          "Content-Type": "application/json",
          "X-EntityId": "incident",
        },
      });
      const incidents = response.data.map((incident: any) => ({
        ...incident,
        id: BigInt(incident.id),
        dateAttribution: incident.dateAttribution ? new Date(incident.dateAttribution).toISOString() : "",
        dateResolution: incident.dateResolution ? new Date(incident.dateResolution).toISOString() : "",
        dateDeclaration: incident.dateDeclaration ? new Date(incident.dateDeclaration).toISOString() : "",
      }));
      return incidents;
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des incidents:", error);
      throw error;
    }
  },

  findMyIncidents: async (igg: string): Promise<IncidentDetail[]> => {
    try {
      const response = await axios.get(`${API_URL}/client/${igg}`, {
        headers: {
          "Content-Type": "application/json",
          "X-EntityId": "incident",
        },
      });
      const incidents = response.data.map((incident: any) => ({
        ...incident,
        id: BigInt(incident.id),
        dateAttribution: incident.dateAttribution ? new Date(incident.dateAttribution).toISOString() : "",
        dateResolution: incident.dateResolution ? new Date(incident.dateResolution).toISOString() : "",
        dateDeclaration: incident.dateDeclaration ? new Date(incident.dateDeclaration).toISOString() : "",
      }));
      return incidents;
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des incidents pour l'IGG:", error);
      throw error;
    }
  },
  
};"use client";

import React, { useState, useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import { toast, ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

import IncidentSummaryPopup from "@/app/view/create-incident/IncidentSummaryPopup";
import IncidentQuestions from "@/app/view/create-incident/IncidentQuestions";
import IncidentHeader from "@/app/view/create-incident/IncidentHeader";
import HeaderBar from "@/app/view/components/HeaderBar";
import Sidebar from "../SideBarComponent/SideBar";

import { Incident } from "@/app/models/Incident";
import { IncidentService } from "@/app/service/IncidentService";
import { IncidentPriority } from "@/app/utils/IncidentPriority";

interface Question {
  id: string;
  text: string;
  type: "text" | "textarea" | "radio" | "select" | "file" | "multitag";
  placeholder?: string;
  options?: string[];
}

const IncidentForm = () => {
  const router = useRouter();
  const [√©tape, set√âtape] = useState(1);
  const [r√©ponses, setR√©ponses] = useState<{ [key: string]: string | string[] | FileList | null }>({});
  const [sla, setSla] = useState("");
  const [priorit√©, setPriorit√©] = useState<IncidentPriority | "">("");
  const [afficherPopup, setAfficherPopup] = useState(false);
  const [champErreur, setChampErreur] = useState<string[]>([]);
  const [dateRapport] = useState(new Date().toLocaleString());
  const refs = useRef<{ [key: string]: HTMLDivElement | null }>({});
  const [transformedAnswers, setTransformedAnswers] = useState<{ [key: string]: string }>({});

  const questionsIncident: Question[] = [
    {
      id: "application",
      text: "Quel application est concern√© par l‚Äôincident ?",
      type: "select",
      options: ["BILL_PAYMENT", "Bankup", "Interop", "OpenR", "Cockpit"]
    },
    {
      id: "environment",
      text: "Quel est l‚Äôenvironnement affect√© ?",
      type: "radio",
      options: ["Dev", "HF", "HT", "Stabilisation"]
    },
    {
      id: "gravit√©",
      text: "Quel est l‚Äôeffet ou les cons√©quences de l‚Äôincident ? (impact)",
      type: "radio",
      options: ["Mineur", "Majeur", "Critique"]
    },
    {
      id: "tags",
      text: "Quels tags correspondent √† cet incident ?",
      type: "multitag",
      options: ["Bridge", "Transfert", "Elevy", "Account", "E-tax", "Guce"]
    },
    {
      id: "shortDescription",
      text: "Quel est l‚Äôobjet principal de l‚Äôincident ?",
      type: "text",
      placeholder: "Exemple : √âchec de l‚Äôauthentification via SSO"
    },
    {
      id: "details",
      text: "D√©crivez les d√©tails techniques de l‚Äôincident",
      type: "textarea",
      placeholder: "Expliquez les √©tapes, erreurs rencontr√©es et cons√©quences fonctionnelles"
    },
    {
      id: "attachments",
      text: "Ajoutez les fichiers n√©cessaires (logs, captures d‚Äô√©cran, etc.)",
      type: "file"
    }
  ];

  const totalQuestions = questionsIncident.length;
  const answeredCount = questionsIncident.filter((q) => {
    const val = r√©ponses[q.id];
    if (q.type === "file") return (val as FileList)?.length > 0;
    if (q.type === "multitag") return (val as string[])?.length > 0;
    return !!val;
  }).length;

  const progress = Math.round((answeredCount / totalQuestions) * 100);

  const g√©rerChangementR√©ponse = (id: string, valeur: string | string[] | FileList | null) => {
    setR√©ponses((prev) => ({ ...prev, [id]: valeur }));
    setChampErreur((prev) => prev.filter((champ) => champ !== id));
  };

  useEffect(() => {
    const gravite = r√©ponses["gravit√©"] as string;
    if (gravite) {
      const priorit√©Map: Record<string, IncidentPriority> = {
        "Critique": IncidentPriority.CRITIQUE,
        "Majeur": IncidentPriority.ELEVEE,
        "Mineur": IncidentPriority.MOYENNE
      };
      const nouvellePriorit√© = priorit√©Map[gravite];
      setPriorit√©(nouvellePriorit√©);
      const slaMap: Record<IncidentPriority, string> = {
        [IncidentPriority.MOYENNE]: "8 heures",
        [IncidentPriority.ELEVEE]: "4 heures",
        [IncidentPriority.CRITIQUE]: "2 heures",
        [IncidentPriority.FAIBLE]: "24 heures"
      };
      setSla(slaMap[nouvellePriorit√©]);
    }
  }, [r√©ponses["gravit√©"]]);

  const handleSubmitClick = async () => {
    const champsManquants = questionsIncident.filter((q) => {
      const val = r√©ponses[q.id];
      if (q.type === "file") return !(val as FileList)?.length;
      if (q.type === "multitag") return !(val as string[])?.length;
      return !val;
    });

    if (champsManquants.length > 0) {
      const ids = champsManquants.map((q) => q.id);
      setChampErreur(ids);
      const firstId = ids[0];
      refs.current[firstId]?.scrollIntoView({ behavior: "smooth", block: "center" });
      toast.error("Veuillez remplir tous les champs.");
      return;
    }

    const transformed: { [key: string]: string } = {};
    for (const [key, val] of Object.entries(r√©ponses)) {
      if (typeof val === "string") {
        transformed[key] = val;
      } else if (val instanceof FileList) {
        transformed[key] = Array.from(val).map((f) => f.name).join(", ");
      } else if (Array.isArray(val)) {
        transformed[key] = val.join(", ");
      }
    }

    setTransformedAnswers(transformed);

    try {
      const formData = new FormData();
      formData.append("titre", transformed.shortDescription || "");
      formData.append("description", transformed.details || "");
      formData.append("gravite", transformed.gravit√© || "");
      formData.append("priorite", priorit√© || "");
      formData.append("clientIgg", localStorage.getItem("clientIgg") || "");
      formData.append("environnement", transformed.environment || "");
      formData.append("application", transformed.application || "");

      if (Array.isArray(r√©ponses.tags)) {
        r√©ponses.tags.forEach((tag) => {
          formData.append("tags[]", tag);
        });
      }

      const fichiers = r√©ponses["attachments"] as FileList;
      if (fichiers && fichiers.length > 0) {
        Array.from(fichiers).forEach((file) => {
          formData.append("files", file);
        });
      }

      await IncidentService.createIncident(formData);
      toast.success("Incident cr√©√© avec succ√®s !");
      setAfficherPopup(true);
      setR√©ponses({});
    } catch (error) {
      console.error("Erreur lors de la cr√©ation de l'incident :", error);
      toast.error("Erreur lors de la cr√©ation de l'incident.");
    }
  };

  return (
    <div className="flex bg-gray-100 min-h-screen">
      <Sidebar />
      <div className="flex-1 flex flex-col">
        <HeaderBar />
        <div className="flex justify-center items-start p-10">
          <div className="w-full max-w-screen-2xl space-y-6">
            <IncidentHeader step={√©tape} progress={progress} />
            <div className="bg-white backdrop-blur-md rounded-2xl shadow-lg p-8">
              <IncidentQuestions
                questions={questionsIncident}
                answers={r√©ponses}
                onAnswerChange={g√©rerChangementR√©ponse}
                errorFields={champErreur}
                refs={refs}
              />
              {sla && (
                <div className="text-right text-sm text-gray-600 font-medium mt-4">
                  ‚è±Ô∏è SLA attribu√© : <span className="text-black font-bold">{sla}</span>
                </div>
              )}
              {priorit√© && (
                <div className="text-right text-sm text-gray-600 font-medium mt-2">
                  üìå Priorit√© calcul√©e : <span className="text-black font-bold">{priorit√©}</span>
                </div>
              )}
              <div className="mt-6 text-center">
                <button
                  onClick={handleSubmitClick}
                  className="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg shadow transition"
                >
                  Soumettre l‚Äôincident
                </button>
              </div>
            </div>
          </div>
        </div>

        <IncidentSummaryPopup
          visible={afficherPopup}
          onClose={() => setAfficherPopup(false)}
          answers={transformedAnswers}
          sla={sla}
          priorit√©={priorit√©}
          reportDate={dateRapport}
        />

        <ToastContainer />
      </div>
    </div>
  );
};

export default IncidentForm;
