import requests
import time
import datetime
import re
from tabulate import tabulate

LOKI_URL = "http://localhost:3100/loki/api/v1/query_range"
OUTPUT_FILE = "loki_logs.txt"

def is_incident(log_line):
    return any(keyword in log_line.lower() for keyword in [
        "exception", "error", "failed", "unknownhost", "refused", "timed out"
    ])

def parse_log_line(log_line):
    # Exemple brut : 2025-06-21T23:14:25.140Z ERROR 1 --- [xxx] message
    pattern = r"^(?P<time>[\d\-T:\.Z]+)\s+(?P<level>[A-Z]+)\s+.*?\]\s+(?P<msg>.*)$"
    match = re.match(pattern, log_line)
    if match:
        return {
            "time": match.group("time"),
            "level": match.group("level"),
            "message": match.group("msg")[:120],  # tronqu√© si trop long
            "incident": "üö®" if is_incident(log_line) else ""
        }
    return {
        "time": "N/A",
        "level": "N/A",
        "message": log_line[:120],
        "incident": "üö®" if is_incident(log_line) else ""
    }

def get_logs():
    now = int(time.time() * 1_000_000_000)
    start = now - 60 * 1_000_000_000
    query = '{service_name="observability-spring-grafana"}'

    params = {
        "query": query,
        "start": start,
        "end": now,
        "limit": 100,
        "direction": "forward"
    }

    try:
        response = requests.get(LOKI_URL, params=params)
        response.raise_for_status()
        data = response.json()
        logs = []

        for stream in data.get("data", {}).get("result", []):
            for entry in stream.get("values", []):
                message = entry[1]
                log = parse_log_line(message)
                logs.append(log)

        return logs

    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erreur de requ√™te Loki : {e}")
        return []

def display_table(logs):
    headers = ["time", "level", "incident", "message"]
    table = [[log["time"], log["level"], log["incident"], log["message"]] for log in logs]
    print(tabulate(table, headers=headers, tablefmt="fancy_grid"))

def run_loop():
    print("üì° D√©marrage de la r√©cup√©ration des logs Loki...\n")
    while True:
        logs = get_logs()
        if logs:
            print(f"‚úÖ {len(logs)} logs r√©cup√©r√©s\n")
            display_table(logs)
        else:
            print("‚ö†Ô∏è Aucun log trouv√©.")
        time.sleep(10)

if __name__ == "__main__":
    run_loop()






------------------------------------------------
import requests
import time

TEMPO_BASE_URL = "http://localhost:3200"
HEADERS = {"Content-Type": "application/json"}

def list_traces(limit=10):
    url = f"{TEMPO_BASE_URL}/api/search"

    now_ns = int(time.time() * 1_000_000_000)
    five_minutes_ago_ns = now_ns - 5 * 60 * 1_000_000_000

    payload = {
        "start": five_minutes_ago_ns,
        "end": now_ns,
        "limit": limit,
        "lookback": "5m",
        "serviceName": "",
    }

    try:
        response = requests.post(url, json=payload, headers=HEADERS)
        response.raise_for_status()
        traces = response.json().get("traces", [])

        if traces:
            print(f"\n‚úÖ {len(traces)} traces trouv√©es :\n")
        for trace in traces:
            trace_id = trace.get("traceID")
            service = trace.get("rootServiceName")
            print(f"üßµ TraceID: {trace_id} | Service: {service}")
            fetch_trace_details(trace_id)
            print("-" * 60)

    except Exception as e:
        print(f"‚ùå Erreur r√©cup√©ration des traces : {e}")

def fetch_trace_details(trace_id):
    url = f"{TEMPO_BASE_URL}/api/traces/{trace_id}"
    try:
        response = requests.get(url, headers=HEADERS)
        response.raise_for_status()
        data = response.json()

        batches = data.get("batches", [])
        for batch in batches:
            scope_spans = batch.get("scopeSpans", [])
            for scope in scope_spans:
                spans = scope.get("spans", [])
                for span in spans:
                    name = span.get("name", "N/A")
                    attributes = span.get("attributes", [])
                    
                    method = uri = status = http_url = exception = outcome = None

                    for attr in attributes:
                        key = attr.get("key", "")
                        val = attr.get("value", {}).get("stringValue", "")

                        if key == "method":
                            method = val
                        elif key == "uri":
                            uri = val
                        elif key == "status":
                            status = val
                        elif key == "http.url":
                            http_url = val
                        elif key == "exception":
                            exception = val
                        elif key == "outcome":
                            outcome = val

                    print(f"   ‚û§ Span: {name}")
                    print(f"      ‚Ä¢ Method     : {method}")
                    print(f"      ‚Ä¢ URI        : {uri}")
                    print(f"      ‚Ä¢ Status     : {status}")
                    print(f"      ‚Ä¢ HTTP URL   : {http_url}")
                    print(f"      ‚Ä¢ Outcome    : {outcome}")
                    print(f"      ‚Ä¢ Exception  : {exception}")

    except Exception as e:
        print(f"‚ùå Erreur d√©tails trace {trace_id} : {e}")

if __name__ == "__main__":
    print("üì° Surveillance en temps r√©el des traces Tempo...\n")
    seen_traces = set()
    while True:
        try:
            url = f"{TEMPO_BASE_URL}/api/search"

            now_ns = int(time.time() * 1_000_000_000)
            one_min_ago_ns = now_ns - 60 * 1_000_000_000

            payload = {
                "start": one_min_ago_ns,
                "end": now_ns,
                "limit": 20,
                "lookback": "1m"
            }

            response = requests.post(url, json=payload, headers=HEADERS)
            response.raise_for_status()
            traces = response.json().get("traces", [])

            for trace in traces:
                trace_id = trace.get("traceID")
                if trace_id not in seen_traces:
                    seen_traces.add(trace_id)
                    service = trace.get("rootServiceName")
                    print(f"\nüßµ Nouvelle trace: {trace_id} | Service: {service}")
                    fetch_trace_details(trace_id)
                    print("-" * 60)

            time.sleep(10)

        except KeyboardInterrupt:
            print("\nüõë Arr√™t manuel.")
            break
        except Exception as e:
            print(f"‚ùå Erreur boucle principale : {e}")
            time.sleep(5)
